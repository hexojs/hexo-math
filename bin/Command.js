// Generated by CoffeeScript 1.6.3
var Command, Layout, Log, assetDir, async, check, colors, doneOrFail, file, fs, inject, layoutDir, list, load, log, mathJaxLayoutAsset, mathJaxLayoutFile, mathJaxLayoutName, pad, path, remove, themeDir, yesOrNo;

colors = require('colors');

Log = require('./Log');

Layout = require('./Layout');

async = require('async');

fs = require('fs');

path = require('path');

log = new Log();

file = hexo.file;

themeDir = hexo.theme_dir;

layoutDir = path.resolve(themeDir, "layout");

assetDir = path.resolve(__dirname, "../asset");

mathJaxLayoutName = "math-jax.ejs";

mathJaxLayoutAsset = path.resolve(assetDir, mathJaxLayoutName);

mathJaxLayoutFile = path.resolve(layoutDir, "_partial", mathJaxLayoutName);

pad = function(val, length, padChar) {
  var numPads;
  if (padChar == null) {
    padChar = '.';
  }
  val += '';
  numPads = length - val.length;
  if (numPads > 0) {
    return val + new Array(numPads + 1).join(padChar);
  } else {
    return val;
  }
};

yesOrNo = function(b) {
  var answer;
  answer = b ? "YES".green : "NO".red;
  return "" + "[".bold + answer + "]".bold;
};

doneOrFail = function(b) {
  var answer;
  answer = b ? "DONE".green : "FAIL".red;
  return "" + "[".bold + answer + "]".bold;
};

load = function(files, callback) {
  var makeTask, tasks;
  tasks = [];
  makeTask = function(path) {
    return function(cb) {
      var layout;
      layout = new Layout(path);
      return layout.load(cb);
    };
  };
  files.forEach(function(f) {
    var fullPath;
    fullPath = path.resolve(layoutDir, f);
    return tasks.push(makeTask(fullPath));
  });
  return async.parallel(tasks, function(err, results) {
    var heads;
    if (err != null) {
      if (typeof next === "function") {
        next(err);
      }
    }
    log.info("Load " + results.length + " layout files");
    heads = results.filter(function(l) {
      return l.hasHead;
    });
    log.info("Found " + heads.length + " with <head>");
    return typeof callback === "function" ? callback(null, heads) : void 0;
  });
};

list = function(next) {
  log.info("Layout folder: " + layoutDir);
  return file.list(layoutDir, null, function(err, files) {
    if (err != null) {
      if (typeof next === "function") {
        next(err);
      }
    }
    files = files.filter(function(f) {
      return f.match(".*?\.ejs$");
    });
    log.info("Found " + files.length + " layout files");
    return typeof next === "function" ? next(null, files) : void 0;
  });
};

check = function(layouts, next) {
  var deployed;
  deployed = fs.existsSync(mathJaxLayoutFile);
  log.info(pad("Layout math-jax.ejs deployed ", 50) + (" " + (yesOrNo(deployed))));
  return load(layouts, function(err, headLayouts) {
    var i, injected, layout, _i, _len;
    if (err != null) {
      if (typeof next === "function") {
        next(err);
      }
      return;
    }
    injected = true;
    for (i = _i = 0, _len = headLayouts.length; _i < _len; i = ++_i) {
      layout = headLayouts[i];
      log.info(pad("Injected " + (i + 1) + " of " + headLayouts.length + " ", 50) + (" " + (yesOrNo(layout.injected))));
      if (!layout.injected) {
        injected = false;
      }
    }
    return typeof next === "function" ? next(null, {
      deployed: deployed,
      layouts: headLayouts,
      injected: injected
    }) : void 0;
  });
};

inject = function(payload, next) {
  var error, layout, tasks, _i, _len, _ref;
  if (payload.deployed && payload.injected) {
    log.info("Already installed.");
    if (typeof next === "function") {
      next(null, payload);
    }
    return;
  }
  if (!payload.deployed) {
    try {
      console.log("" + mathJaxLayoutAsset + " exists: " + (fs.existsSync(mathJaxLayoutAsset)));
      console.log("" + mathJaxLayoutFile + " exists: " + (fs.existsSync(mathJaxLayoutFile)));
      fs.linkSync(mathJaxLayoutAsset, mathJaxLayoutFile);
      log.info(pad("Deploy math-jax.ejs ", 50) + (" " + (doneOrFail(true))));
    } catch (_error) {
      error = _error;
      log.error(pad("Deploy math-jax.ejs ", 50) + (" " + (doneOrFail(false))));
      log.error(error);
    }
  }
  tasks = [];
  _ref = payload.layouts;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    layout = _ref[_i];
    if (!layout.injected) {
      tasks.push(function(callback) {
        layout.inject();
        return layout.update(callback);
      });
    }
  }
  return async.parallel(tasks, function(err, results) {
    var e, _j, _len1;
    if (err != null) {
      log.error(pad("Inject " + err.length + " layouts", 50) + (" " + (doneOrFail(false))));
      for (_j = 0, _len1 = err.length; _j < _len1; _j++) {
        e = err[_j];
        log.error(e);
      }
      if (typeof next === "function") {
        next(err);
      }
    }
    log.info(pad("Inject " + results.length + " layouts", 50) + (" " + (doneOrFail(true))));
    return typeof next === "function" ? next(null, null) : void 0;
  });
};

remove = function(payload, next) {
  var error, layout, tasks, _i, _len, _ref;
  if (!payload.deployed && !payload.injected) {
    log.info("Not installed.");
    if (typeof next === "function") {
      next(null, payload);
    }
    return;
  }
  if (payload.deployed) {
    try {
      fs.unlinkSync(mathJaxLayoutFile);
      log.info(pad("Undeploy math-jax.ejs ", 50) + (" " + (doneOrFail(true))));
    } catch (_error) {
      error = _error;
      log.error(pad("Undeploy math-jax.ejs ", 50) + (" " + (doneOrFail(false))));
      log.error(error);
    }
  }
  tasks = [];
  _ref = payload.layouts;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    layout = _ref[_i];
    if (layout.injected) {
      tasks.push(function(callback) {
        layout.uninject();
        return layout.update(callback);
      });
    }
  }
  return async.parallel(tasks, function(err, results) {
    var e, _j, _len1;
    if (err != null) {
      log.error(pad("Uninject " + err.length + " layouts", 50) + (" " + (doneOrFail(false))));
      for (_j = 0, _len1 = err.length; _j < _len1; _j++) {
        e = err[_j];
        log.error(e);
      }
      if (typeof next === "function") {
        next(err);
      }
    }
    log.info(pad("Uninject " + results.length + " layouts", 50) + (" " + (doneOrFail(true))));
    return typeof next === "function" ? next(null, null) : void 0;
  });
};

module.exports = Command = (function() {
  function Command(callback) {
    this.callback = callback;
  }

  Command.prototype.execute = function(opt) {
    var handler;
    handler = this[opt];
    if (handler != null) {
      return handler();
    } else {
      log.error("Unknown command: " + opt);
      return hexo.call('help', {
        _: ['math']
      }, this.callback);
    }
  };

  Command.prototype.install = function() {
    return async.waterfall([list, check, inject], function(err, result) {
      if (err != null) {
        return log.error(err);
      } else {
        return log.info("Done!");
      }
    });
  };

  Command.prototype.uninstall = function() {
    return async.waterfall([list, check, remove], function(err, result) {
      if (err != null) {
        return log.error(err);
      } else {
        return log.info("Done!");
      }
    });
  };

  return Command;

})();
